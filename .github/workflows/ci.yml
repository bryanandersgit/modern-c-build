# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  # Customize the CMake build type here (Release, Debug, RelWithDebInfo, etc.)
  BUILD_TYPE: Release

jobs:
  # Job 1: Build and test on multiple platforms
  build-and-test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        build_type: [Release, Debug]

    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Get latest CMake
        uses: lukka/get-cmake@latest

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          # This specifies the location of vcpkg, where it is going to be restored
          # and built as part of the workflow.
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          # The Git commit id of vcpkg to be checked out. This is only used if
          # vcpkgGitCommitId is not specified.
          vcpkgGitCommitId: '903956eff7cb94774a9e805ff573c000afc43e3e'
          # The vcpkg.json file, which will be part of cache key computation.
          vcpkgJsonGlob: '**/vcpkg.json'

      - name: Configure CMake
        run: cmake -B build -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_FLAGS="--coverage -fprofile-arcs -ftest-coverage"

      - name: Build
        run: cmake --build ${{ github.workspace }}/build --config ${{ matrix.build_type }}

      - name: Test
        working-directory: ${{ github.workspace }}/build
        run: ctest -C ${{ matrix.build_type }} --output-on-failure

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: matrix.build_type == 'Release'
        with:
          name: binaries-${{ matrix.os }}
          path: |
            build/bin/*
            build/Release/*.exe
            build/*.exe
          retention-days: 30

  # Job 2: Static Analysis with clang-tidy
  static-analysis:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install clang-tidy
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tidy

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          vcpkgGitCommitId: '903956eff7cb94774a9e805ff573c000afc43e3e'
          vcpkgJsonGlob: '**/vcpkg.json'

      - name: Configure CMake with clang-tidy
        run: cmake -B build -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_FLAGS="--coverage -fprofile-arcs -ftest-coverage" -DCMAKE_C_CLANG_TIDY="clang-tidy;--warnings-as-errors=*"

      - name: Build with static analysis
        run: cmake --build build

  # Job 3: Memory check with Valgrind (Linux only)
  memory-check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Valgrind
        run: |
          sudo apt-get update
          sudo apt-get install -y valgrind

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          vcpkgGitCommitId: '903956eff7cb94774a9e805ff573c000afc43e3e'
          vcpkgJsonGlob: '**/vcpkg.json'

      - name: Configure CMake
        run: cmake -B build -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_FLAGS="--coverage -fprofile-arcs -ftest-coverage"

      - name: Build
        run: cmake --build build

      - name: Run tests with Valgrind
        working-directory: build
        run: |
          # Run each test executable with Valgrind
          for test_exe in tests package_test; do
            if [ -f "$test_exe" ]; then
              echo "Running $test_exe with Valgrind..."
              valgrind --tool=memcheck --leak-check=full --error-exitcode=1 ./$test_exe
            fi
          done

  # Job 4: Code Coverage (Linux only)
  coverage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install coverage tools
        run: |
          sudo apt-get update
          sudo apt-get install -y \
          build-essential \
          cmake \
          ninja-build \
          gcc \
          g++ \
          lcov \
          pkg-config \
          curl \
          zip \
          unzip \
          tar \
          python3-pip
          sudo python3 -m pip install gcovr

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          vcpkgGitCommitId: '903956eff7cb94774a9e805ff573c000afc43e3e'
          vcpkgJsonGlob: '**/vcpkg.json'

      - name: Configure CMake with coverage
        run: cmake -B build -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_FLAGS="--coverage -fprofile-arcs -ftest-coverage"

      - name: Build
        run: cmake --build build

      - name: Run tests
        working-directory: build
        run: ctest --output-on-failure

      - name: Generate coverage report
        run: |
          # Generate initial coverage data
          lcov --directory build --capture --output-file coverage_raw.info
          
          # Filter out unwanted files
          lcov --extract coverage_raw.info \
          '*/src/*' \
          --output-file coverage.info

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.info
          flags: unittests
          name: codecov-umbrella

  # Job 5: Package and Release (only on tags)
  package-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          vcpkgGitCommitId: '2024.11.16'
          vcpkgJsonGlob: '**/vcpkg.json'

      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake

      - name: Build
        run: cmake --build build

      - name: Run tests
        working-directory: build
        run: ctest --output-on-failure

      - name: Create packages
        run: |
          cd build
          cpack -G "TGZ;ZIP"  # Create both tar.gz and zip
          echo "=== Generated packages ==="
          ls -la *.tar.gz *.zip 2>/dev/null || true

      - name: Generate changelog
        id: changelog
        run: |
          # Get the previous release tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          CURRENT_TAG=${{ github.ref_name }}
          
          # Create temporary changelog file
          CHANGELOG_FILE=$(mktemp)
          
          echo "# Release $CURRENT_TAG" > "$CHANGELOG_FILE"
          echo "" >> "$CHANGELOG_FILE"
          
          # Create changelog file directly with echo commands
          echo "# Release $CURRENT_TAG" > release_changelog.md
          echo "" >> release_changelog.md
          echo "## What's Changed in This Release" >> release_changelog.md
          echo "" >> release_changelog.md
          
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...$CURRENT_TAG" >> release_changelog.md
            echo "" >> release_changelog.md
            echo "### Commits since $PREVIOUS_TAG:" >> release_changelog.md
            git log --pretty=format:"- %s (%h)" ${PREVIOUS_TAG}..HEAD >> release_changelog.md
          else
            echo "**Initial Release** " >> release_changelog.md
            echo "" >> release_changelog.md
            echo "### All commits in this release:" >> release_changelog.md
            git log --pretty=format:"- %s (%h)" HEAD >> release_changelog.md
          fi
          
          echo "" >> release_changelog.md
          echo "---" >> release_changelog.md
          echo "*Changelog generated automatically from git commits*" >> release_changelog.md
          
          # Simple variable assignment - no heredoc syntax at all
          echo "changelog_file=release_changelog.md" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body: ${{ steps.changelog.outputs.changelog }}
          files: |
            build/*.tar.gz
            build/*.zip
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref_name, '-rc') || contains(github.ref_name, '-beta') || contains(github.ref_name, '-alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}